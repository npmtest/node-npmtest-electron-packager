{"/home/travis/build/npmtest/node-npmtest-electron-packager/test.js":"/* istanbul instrument in package npmtest_electron_packager */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-electron-packager/lib.npmtest_electron_packager.js":"/* istanbul instrument in package npmtest_electron_packager */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_electron_packager = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_electron_packager = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-electron-packager/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-electron-packager && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_electron_packager */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_electron_packager\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_electron_packager.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_electron_packager.rollup.js'] =\n            local.assetsDict['/assets.npmtest_electron_packager.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_electron_packager.__dirname +\n                    '/lib.npmtest_electron_packager.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-electron-packager/node_modules/electron-packager/index.js":"'use strict'\n\nconst common = require('./common')\nconst debug = require('debug')('electron-packager')\nconst extract = require('extract-zip')\nconst fs = require('fs-extra')\nconst getMetadataFromPackageJSON = require('./infer')\nconst ignore = require('./ignore')\nconst metadata = require('./package.json')\nconst path = require('path')\nconst series = require('run-series')\nconst targets = require('./targets')\n\nfunction debugHostInfo () {\n  debug(`Electron Packager ${metadata.version}`)\n  debug(`Node ${process.version}`)\n  debug(`Host Operating system: ${process.platform} (${process.arch})`)\n}\n\nfunction createSeries (opts, archs, platforms) {\n  const tempBase = common.baseTempDir(opts)\n\n  function testSymlink (cb) {\n    var testPath = path.join(tempBase, 'symlink-test')\n    var testFile = path.join(testPath, 'test')\n    var testLink = path.join(testPath, 'testlink')\n    series([\n      function (cb) {\n        fs.outputFile(testFile, '', cb)\n      },\n      function (cb) {\n        fs.symlink(testFile, testLink, cb)\n      }\n    ], function (err) {\n      var result = !err\n      fs.remove(testPath, function () {\n        cb(result) // ignore errors on cleanup\n      })\n    })\n  }\n\n  var tasks = []\n  var useTempDir = opts.tmpdir !== false\n  if (useTempDir) {\n    tasks.push(function (cb) {\n      fs.remove(tempBase, cb)\n    })\n  }\n  return tasks.concat(common.createDownloadCombos(opts, platforms, archs).map(combination => {\n    var arch = combination.arch\n    var platform = combination.platform\n    var version = combination.version\n\n    return (callback) => {\n      common.downloadElectronZip(combination, (err, zipPath) => {\n        if (err) return callback(err)\n\n        function createApp (comboOpts) {\n          var buildParentDir\n          if (useTempDir) {\n            buildParentDir = tempBase\n          } else {\n            buildParentDir = opts.out || process.cwd()\n          }\n          var buildDir = path.join(buildParentDir, `${platform}-${arch}-template`)\n          common.info(`Packaging app for platform ${platform} ${arch} using electron v${version}`, opts.quiet)\n          series([\n            function (cb) {\n              debug(`Creating ${buildDir}`)\n              fs.mkdirs(buildDir, cb)\n            },\n            function (cb) {\n              debug(`Extracting ${zipPath} to ${buildDir}`)\n              extract(zipPath, {dir: buildDir}, cb)\n            },\n            function (cb) {\n              if (!opts.afterExtract || !Array.isArray(opts.afterExtract)) {\n                cb()\n              } else {\n                var newFunctions = opts.afterExtract.map(function (fn) {\n                  return fn.bind(this, buildDir, version, platform, arch)\n                })\n                series(newFunctions, cb)\n              }\n            }\n          ], function () {\n            require(targets.supportedPlatforms[platform]).createApp(comboOpts, buildDir, callback)\n          })\n        }\n\n        // Create delegated options object with specific platform and arch, for output directory naming\n        var comboOpts = Object.create(opts)\n        comboOpts.arch = arch\n        comboOpts.platform = platform\n        comboOpts.version = version\n        comboOpts.afterCopy = opts.afterCopy\n\n        if (!useTempDir) {\n          createApp(comboOpts)\n          return\n        }\n\n        function checkOverwrite () {\n          var finalPath = common.generateFinalPath(comboOpts)\n          fs.exists(finalPath, function (exists) {\n            if (exists) {\n              if (opts.overwrite) {\n                fs.remove(finalPath, function () {\n                  createApp(comboOpts)\n                })\n              } else {\n                common.info(`Skipping ${platform} ${arch} (output dir already exists, use --overwrite to force)`, opts.quiet)\n                callback()\n              }\n            } else {\n              createApp(comboOpts)\n            }\n          })\n        }\n\n        if (common.isPlatformMac(combination.platform)) {\n          testSymlink(function (result) {\n            if (result) return checkOverwrite()\n\n            common.info(`Cannot create symlinks (on Windows hosts, it requires admin privileges); skipping ${combination.platform} platform`, opts.quiet)\n            callback()\n          })\n        } else {\n          checkOverwrite()\n        }\n      })\n    }\n  }))\n}\n\nmodule.exports = function packager (opts, cb) {\n  debugHostInfo()\n  if (debug.enabled) debug(`Packager Options: ${JSON.stringify(opts)}`)\n\n  let archs = targets.validateListFromOptions(opts, targets.supportedArchs, 'arch')\n  let platforms = targets.validateListFromOptions(opts, targets.supportedPlatforms, 'platform')\n  if (!Array.isArray(archs)) return cb(archs)\n  if (!Array.isArray(platforms)) return cb(platforms)\n\n  debug(`Target Platforms: ${platforms.join(', ')}`)\n  debug(`Target Architectures: ${archs.join(', ')}`)\n\n  common.deprecatedParameter(opts, 'version', 'electronVersion', 'electron-version')\n\n  common.camelCase(opts, true)\n\n  getMetadataFromPackageJSON(opts, path.resolve(process.cwd(), opts.dir) || process.cwd(), function (err) {\n    if (err) return cb(err)\n\n    if (/ Helper$/.test(opts.name)) {\n      return cb(new Error('Application names cannot end in \" Helper\" due to limitations on macOS'))\n    }\n\n    debug(`Application name: ${opts.name}`)\n    debug(`Target Electron version: ${opts.electronVersion}`)\n\n    ignore.generateIgnores(opts)\n\n    series(createSeries(opts, archs, platforms), function (err, appPaths) {\n      if (err) return cb(err)\n\n      cb(null, appPaths.filter(function (appPath) {\n        // Remove falsy entries (e.g. skipped platforms)\n        return appPath\n      }))\n    })\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-electron-packager/node_modules/electron-packager/common.js":"'use strict'\n\nconst asar = require('asar')\nconst child = require('child_process')\nconst debug = require('debug')('electron-packager')\nconst download = require('electron-download')\nconst fs = require('fs-extra')\nconst ignore = require('./ignore')\nconst minimist = require('minimist')\nconst os = require('os')\nconst path = require('path')\nconst sanitize = require('sanitize-filename')\nconst semver = require('semver')\nconst series = require('run-series')\n\nconst archs = ['ia32', 'x64', 'armv7l']\nconst platforms = ['darwin', 'linux', 'mas', 'win32']\n\nfunction parseCLIArgs (argv) {\n  var args = minimist(argv, {\n    boolean: [\n      'all',\n      'deref-symlinks',\n      'download.strictSSL',\n      'overwrite',\n      'prune',\n      'quiet'\n    ],\n    default: {\n      'deref-symlinks': true,\n      'download.strictSSL': true,\n      prune: true\n    },\n    string: [\n      'electron-version',\n      'out'\n    ]\n  })\n\n  args.dir = args._[0]\n  args.name = args._[1]\n\n  // Transform hyphenated keys into camelCase\n  module.exports.camelCase(args, false)\n\n  var protocolSchemes = [].concat(args.protocol || [])\n  var protocolNames = [].concat(args.protocolName || [])\n\n  if (protocolSchemes && protocolNames && protocolNames.length === protocolSchemes.length) {\n    args.protocols = protocolSchemes.map(function (scheme, i) {\n      return {schemes: [scheme], name: protocolNames[i]}\n    })\n  }\n\n  if (args.out === '') {\n    args.out = null\n  }\n\n  // Overrides for multi-typed arguments, because minimist doesn't support it\n\n  // asar: `Object` or `true`\n  if (args.asar === 'true' || args.asar instanceof Array) {\n    args.asar = true\n  }\n\n  // osx-sign: `Object` or `true`\n  if (args.osxSign === 'true') {\n    args.osxSign = true\n  }\n\n  // tmpdir: `String` or `false`\n  if (args.tmpdir === 'false') {\n    args.tmpdir = false\n  }\n\n  return args\n}\n\nfunction asarApp (appPath, asarOptions, cb) {\n  var dest = path.join(appPath, '..', 'app.asar')\n  debug(`Running asar with the options ${JSON.stringify(asarOptions)}`)\n  asar.createPackageWithOptions(appPath, dest, asarOptions, function (err) {\n    if (err) return cb(err)\n    fs.remove(appPath, function (err) {\n      if (err) return cb(err)\n      cb(null, dest)\n    })\n  })\n}\n\nfunction isPlatformMac (platform) {\n  return platform === 'darwin' || platform === 'mas'\n}\n\nfunction sanitizeAppName (name) {\n  return sanitize(name, {replacement: '-'})\n}\n\nfunction generateFinalBasename (opts) {\n  return `${sanitizeAppName(opts.name)}-${opts.platform}-${opts.arch}`\n}\n\nfunction generateFinalPath (opts) {\n  return path.join(opts.out || process.cwd(), generateFinalBasename(opts))\n}\n\nfunction info (message, quiet) {\n  if (!quiet) {\n    console.error(message)\n  }\n}\n\nfunction warning (message, quiet) {\n  if (!quiet) {\n    console.warn(`WARNING: ${message}`)\n  }\n}\n\nfunction subOptionWarning (properties, optionName, parameter, value, quiet) {\n  if (properties.hasOwnProperty(parameter)) {\n    warning(`${optionName}.${parameter} will be inferred from the main options`, quiet)\n  }\n  properties[parameter] = value\n}\n\nfunction baseTempDir (opts) {\n  return path.join(opts.tmpdir || os.tmpdir(), 'electron-packager')\n}\n\nfunction createAsarOpts (opts) {\n  let asarOptions\n  if (opts.asar === true) {\n    asarOptions = {}\n  } else if (typeof opts.asar === 'object') {\n    asarOptions = opts.asar\n  } else if (opts.asar === false || opts.asar === undefined) {\n    return false\n  } else {\n    warning(`asar parameter set to an invalid value (${opts.asar}), ignoring and disabling asar`)\n    return false\n  }\n\n  return asarOptions\n}\n\nfunction createDownloadOpts (opts, platform, arch) {\n  let downloadOpts = Object.assign({}, opts.download)\n\n  subOptionWarning(downloadOpts, 'download', 'platform', platform, opts.quiet)\n  subOptionWarning(downloadOpts, 'download', 'arch', arch, opts.quiet)\n  subOptionWarning(downloadOpts, 'download', 'version', opts.electronVersion, opts.quiet)\n\n  return downloadOpts\n}\n\nmodule.exports = {\n  archs: archs,\n  platforms: platforms,\n\n  parseCLIArgs: parseCLIArgs,\n\n  isPlatformMac: isPlatformMac,\n\n  subOptionWarning: subOptionWarning,\n\n  baseTempDir: baseTempDir,\n\n  createAsarOpts: createAsarOpts,\n  createDownloadOpts: createDownloadOpts,\n  createDownloadCombos: function createDownloadCombos (opts, selectedPlatforms, selectedArchs, ignoreFunc) {\n    let combinations = []\n    for (let arch of selectedArchs) {\n      for (let platform of selectedPlatforms) {\n        // Electron does not have 32-bit releases for Mac OS X, so skip that combination\n        if (isPlatformMac(platform) && arch === 'ia32') continue\n        // Electron only has armv7l releases for Linux\n        if (arch === 'armv7l' && platform !== 'linux') continue\n        if (typeof ignoreFunc === 'function' && ignoreFunc(platform, arch)) continue\n        combinations.push(createDownloadOpts(opts, platform, arch))\n      }\n    }\n\n    return combinations\n  },\n\n  deprecatedParameter: function deprecatedParameter (properties, oldName, newName, newCLIName) {\n    if (properties.hasOwnProperty(oldName)) {\n      warning(`The ${oldName} parameter is deprecated, use ${newName} (or --${newCLIName} in the CLI) instead`)\n      if (!properties.hasOwnProperty(newName)) {\n        properties[newName] = properties[oldName]\n      }\n      delete properties[oldName]\n    }\n  },\n\n  kebabProperties: {\n    'electron-version': 'electronVersion',\n    'app-copyright': 'appCopyright',\n    'app-version': 'appVersion',\n    'build-version': 'buildVersion',\n    'app-bundle-id': 'appBundleId',\n    'app-category-type': 'appCategoryType',\n    'extend-info': 'extendInfo',\n    'extra-resource': 'extraResource',\n    'helper-bundle-id': 'helperBundleId',\n    'osx-sign': 'osxSign',\n    'protocol-name': 'protocolName'\n  },\n\n  camelCase: function camelCase (properties, warn) {\n    Object.keys(module.exports.kebabProperties).forEach(function (key) {\n      var value = module.exports.kebabProperties[key]\n      if (properties.hasOwnProperty(key)) {\n        if (warn) {\n          warning(`The ${key} parameter is deprecated when used from JS, use ${value} instead. It will be removed in the next major version.`)\n        }\n        if (!properties.hasOwnProperty(value)) {\n          properties[value] = properties[key]\n        }\n        delete properties[key]\n      }\n    })\n  },\n\n  downloadElectronZip: function downloadElectronZip (downloadOpts, cb) {\n    // armv7l builds have only been backfilled for Electron >= 1.0.0.\n    // See: https://github.com/electron/electron/pull/6986\n    if (downloadOpts.arch === 'armv7l' && semver.lt(downloadOpts.version, '1.0.0')) {\n      downloadOpts.arch = 'arm'\n    }\n    debug(`Downloading Electron with options ${JSON.stringify(downloadOpts)}`)\n    download(downloadOpts, cb)\n  },\n\n  generateFinalBasename: generateFinalBasename,\n  generateFinalPath: generateFinalPath,\n\n  info: info,\n\n  initializeApp: function initializeApp (opts, templatePath, appRelativePath, callback) {\n    // Performs the following initial operations for an app:\n    // * Creates temporary directory\n    // * Copies template into temporary directory\n    // * Copies user's app into temporary directory\n    // * Prunes non-production node_modules (if opts.prune is either truthy or undefined)\n    // * Creates an asar (if opts.asar is set)\n\n    var tempPath\n    if (opts.tmpdir === false) {\n      tempPath = generateFinalPath(opts)\n    } else {\n      tempPath = path.join(baseTempDir(opts), `${opts.platform}-${opts.arch}`, generateFinalBasename(opts))\n    }\n\n    debug(`Initializing app in ${tempPath} from ${templatePath} template`)\n\n    // Path to `app` directory\n    var appPath = path.join(tempPath, appRelativePath)\n    var resourcesPath = path.resolve(appPath, '..')\n\n    var operations = [\n      function (cb) {\n        fs.move(templatePath, tempPath, {clobber: true}, cb)\n      },\n      function (cb) {\n        // `deref-symlinks` is the default value so we'll use it unless\n        // `derefSymlinks` is defined.\n        var shouldDeref = opts['deref-symlinks']\n        if (opts.derefSymlinks !== undefined) {\n          shouldDeref = opts.derefSymlinks\n        }\n\n        fs.copy(opts.dir, appPath, {filter: ignore.userIgnoreFilter(opts), dereference: shouldDeref}, cb)\n      },\n      function (cb) {\n        var afterCopyHooks = (opts.afterCopy || []).map(function (afterCopyFn) {\n          return function (cb) {\n            afterCopyFn(appPath, opts.electronVersion, opts.platform, opts.arch, cb)\n          }\n        })\n        series(afterCopyHooks, cb)\n      },\n      function (cb) {\n        // Support removing old default_app folder that is now an asar archive\n        fs.remove(path.join(resourcesPath, 'default_app'), cb)\n      },\n      function (cb) {\n        fs.remove(path.join(resourcesPath, 'default_app.asar'), cb)\n      }\n    ]\n\n    // Prune and asar are now performed before platform-specific logic, primarily so that\n    // appPath is predictable (e.g. before .app is renamed for mac)\n    if (opts.prune || opts.prune === undefined) {\n      operations.push(function (cb) {\n        debug('Running npm prune --production')\n        child.exec('npm prune --production', {cwd: appPath}, cb)\n      })\n    }\n\n    let asarOptions = createAsarOpts(opts)\n    if (asarOptions) {\n      operations.push(function (cb) {\n        asarApp(appPath, asarOptions, cb)\n      })\n    }\n\n    series(operations, function (err) {\n      if (err) return callback(err)\n      // Resolve to path to temporary app folder for platform-specific processes to use\n      callback(null, tempPath)\n    })\n  },\n\n  moveApp: function finalizeApp (opts, tempPath, callback) {\n    var finalPath = generateFinalPath(opts)\n\n    if (opts.tmpdir === false) {\n      callback(null, finalPath)\n      return\n    }\n\n    debug(`Moving ${tempPath} to ${finalPath}`)\n    fs.move(tempPath, finalPath, function (err) {\n      callback(err, finalPath)\n    })\n  },\n\n  normalizeExt: function normalizeExt (filename, targetExt, cb) {\n    // Forces a filename to a given extension and fires the given callback with the normalized filename,\n    // if it exists.  Otherwise reports the error from the fs.stat call.\n    // (Used for resolving icon filenames, particularly during --all runs.)\n\n    // This error path is used by win32.js if no icon is specified\n    if (!filename) return cb(new Error('No filename specified to normalizeExt'))\n\n    var ext = path.extname(filename)\n    if (ext !== targetExt) {\n      filename = filename.slice(0, filename.length - ext.length) + targetExt\n    }\n\n    fs.stat(filename, function (err) {\n      cb(err, err ? null : filename)\n    })\n  },\n\n  rename: function rename (basePath, oldName, newName, cb) {\n    debug(`Renaming ${oldName} to ${newName} in ${basePath}`)\n    fs.rename(path.join(basePath, oldName), path.join(basePath, newName), cb)\n  },\n  sanitizeAppName: sanitizeAppName,\n  warning: warning\n}\n","/home/travis/build/npmtest/node-npmtest-electron-packager/node_modules/electron-packager/ignore.js":"'use strict'\n\nconst debug = require('debug')('electron-packager')\nconst path = require('path')\n\nconst DEFAULT_IGNORES = [\n  '/node_modules/electron($|/)',\n  '/node_modules/electron-prebuilt(-compile)?($|/)',\n  '/node_modules/electron-packager($|/)',\n  '/\\\\.git($|/)',\n  '/node_modules/\\\\.bin($|/)',\n  '\\\\.o(bj)?$'\n]\n\nfunction generateIgnores (opts) {\n  if (typeof (opts.ignore) !== 'function') {\n    // Avoid a circular require that breaks things\n    const common = require('./common')\n\n    if (opts.ignore && !Array.isArray(opts.ignore)) opts.ignore = [opts.ignore]\n    opts.ignore = (opts.ignore) ? opts.ignore.concat(DEFAULT_IGNORES) : [].concat(DEFAULT_IGNORES)\n    if (process.platform === 'linux') {\n      opts.ignore.push(common.baseTempDir(opts))\n    }\n\n    debug('Ignored path regular expressions:', opts.ignore)\n  }\n}\n\nfunction generateOutIgnores (opts) {\n  // Avoid a circular require that breaks things\n  const common = require('./common')\n\n  let normalizedOut = opts.out ? path.resolve(opts.out) : null\n  let outIgnores = []\n  if (normalizedOut === null || normalizedOut === process.cwd()) {\n    for (let platform of common.platforms) {\n      for (let arch of common.archs) {\n        let basenameOpts = {\n          arch: arch,\n          name: opts.name,\n          platform: platform\n        }\n        outIgnores.push(path.join(process.cwd(), common.generateFinalBasename(basenameOpts)))\n      }\n    }\n  } else {\n    outIgnores.push(normalizedOut)\n  }\n\n  debug('Ignored paths based on the out param:', outIgnores)\n\n  return outIgnores\n}\n\nfunction userIgnoreFilter (opts) {\n  var ignore = opts.ignore || []\n  var ignoreFunc = null\n\n  if (typeof (ignore) === 'function') {\n    ignoreFunc = file => { return !ignore(file) }\n  } else {\n    if (!Array.isArray(ignore)) ignore = [ignore]\n\n    ignoreFunc = function filterByRegexes (file) {\n      for (var i = 0; i < ignore.length; i++) {\n        if (file.match(ignore[i])) {\n          return false\n        }\n      }\n\n      return true\n    }\n  }\n\n  let outIgnores = generateOutIgnores(opts)\n\n  return function filter (file) {\n    if (outIgnores.indexOf(file) !== -1) {\n      return false\n    }\n\n    var name = file.split(path.resolve(opts.dir))[1]\n\n    if (path.sep === '\\\\') {\n      // convert slashes so unix-format ignores work\n      name = name.replace(/\\\\/g, '/')\n    }\n\n    return ignoreFunc(name)\n  }\n}\n\nmodule.exports = {\n  generateIgnores: generateIgnores,\n  generateOutIgnores: generateOutIgnores,\n  userIgnoreFilter: userIgnoreFilter\n}\n","/home/travis/build/npmtest/node-npmtest-electron-packager/node_modules/electron-packager/infer.js":"'use strict'\n\nconst debug = require('debug')('electron-packager')\nconst getPackageInfo = require('get-package-info')\nconst path = require('path')\nconst resolve = require('resolve')\n\nfunction isMissingRequiredProperty (props) {\n  var requiredProps = props.filter(\n    (prop) => prop === 'productName' || prop === 'dependencies.electron'\n  )\n  return requiredProps.length !== 0\n}\n\nfunction errorMessageForProperty (prop) {\n  let hash, propDescription\n  switch (prop) {\n    case 'productName':\n      hash = 'name'\n      propDescription = 'application name'\n      break\n    case 'dependencies.electron':\n      hash = 'electronversion'\n      propDescription = 'Electron version'\n      break\n    default:\n      hash = ''\n      propDescription = '[Unknown Property]'\n  }\n\n  return `Unable to determine ${propDescription}. Please specify an ${propDescription}\\n\\n` +\n    'For more information, please see\\n' +\n    `https://github.com/electron-userland/electron-packager/blob/master/docs/api.md#${hash}\\n`\n}\n\nfunction getVersion (opts, electronProp, cb) {\n  // Destructured assignments are added in Node 6\n  const splitProp = electronProp.prop.split('.')\n  const depType = splitProp[0]\n  const packageName = splitProp[1]\n  const src = electronProp.src\n  if (packageName === 'electron-prebuilt-compile') {\n    // electron-prebuilt-compile cannot be resolved because `main` does not point\n    // to a valid JS file.\n    const electronVersion = electronProp.pkg[depType][packageName]\n    if (!/^\\d+\\.\\d+\\.\\d+/.test(electronVersion)) {\n      return cb(new Error('Using electron-prebuilt-compile with Electron Packager requires specifying an exact Electron version'))\n    }\n\n    opts.electronVersion = electronVersion\n    return cb(null)\n  } else {\n    resolve(packageName, {\n      basedir: path.dirname(src)\n    }, (err, res, pkg) => {\n      if (err) return cb(err)\n      debug(`Inferring target Electron version from ${packageName} in ${src}`)\n      opts.electronVersion = pkg.version\n      return cb(null)\n    })\n  }\n}\n\nmodule.exports = function getMetadataFromPackageJSON (opts, dir, cb) {\n  let props = []\n  if (!opts.name) props.push(['productName', 'name'])\n  if (!opts.appVersion) props.push('version')\n  if (!opts.electronVersion) {\n    props.push([\n      'dependencies.electron',\n      'devDependencies.electron',\n      'dependencies.electron-prebuilt-compile',\n      'devDependencies.electron-prebuilt-compile',\n      'dependencies.electron-prebuilt',\n      'devDependencies.electron-prebuilt'\n    ])\n  }\n\n  // Name and version provided, no need to infer\n  if (props.length === 0) return cb(null)\n\n  // Search package.json files to infer name and version from\n  getPackageInfo(props, dir, (err, result) => {\n    if (err && err.missingProps) {\n      let missingProps = err.missingProps.map(prop => {\n        return Array.isArray(prop) ? prop[0] : prop\n      })\n\n      if (isMissingRequiredProperty(missingProps)) {\n        let messages = missingProps.map(errorMessageForProperty)\n\n        debug(err.message)\n        err.message = messages.join('\\n') + '\\n'\n        return cb(err)\n      } else {\n        // Missing props not required, can continue w/ partial result\n        result = err.result\n      }\n    } else if (err) {\n      return cb(err)\n    }\n\n    if (result.values.productName) {\n      debug(`Inferring application name from ${result.source.productName.prop} in ${result.source.productName.src}`)\n      opts.name = result.values.productName\n    }\n\n    if (result.values.version) {\n      debug(`Inferring appVersion from version in ${result.source.version.src}`)\n      opts.appVersion = result.values.version\n    }\n\n    if (result.values['dependencies.electron']) {\n      return getVersion(opts, result.source['dependencies.electron'], cb)\n    } else {\n      return cb(null)\n    }\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-electron-packager/node_modules/electron-packager/targets.js":"'use strict'\n\nconst common = require('./common')\n\nfunction unsupportedListOption (name, value, supported) {\n  return new Error(`Unsupported ${name}=${value} (${typeof value}); must be a String matching: ${Object.keys(supported).join(', ')}`)\n}\n\nmodule.exports = {\n  supportedArchs: common.archs.reduce((result, arch) => {\n    result[arch] = true\n    return result\n  }, {}),\n  // Maps to module filename for each platform (lazy-required if used)\n  supportedPlatforms: {\n    darwin: './mac',\n    linux: './linux',\n    mas: './mac', // map to darwin\n    win32: './win32'\n  },\n\n  // Validates list of architectures or platforms.\n  // Returns a normalized array if successful, or throws an Error.\n  validateListFromOptions: function validateListFromOptions (opts, supported, name) {\n    if (opts.all) return Object.keys(supported)\n\n    let list = opts[name] || process[name]\n    if (list === 'all') return Object.keys(supported)\n\n    if (!Array.isArray(list)) {\n      if (typeof list === 'string') {\n        list = list.split(',')\n      } else {\n        return unsupportedListOption(name, list, supported)\n      }\n    }\n\n    for (let value of list) {\n      if (!supported[value]) {\n        return unsupportedListOption(name, value, supported)\n      }\n    }\n\n    return list\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-electron-packager/node_modules/electron-packager/linux.js":"'use strict'\n\nconst common = require('./common')\nconst path = require('path')\n\nmodule.exports = {\n  createApp: function createApp (opts, templatePath, callback) {\n    common.initializeApp(opts, templatePath, path.join('resources', 'app'), function buildLinuxApp (err, tempPath) {\n      if (err) return callback(err)\n      common.rename(tempPath, 'electron', common.sanitizeAppName(opts.name), function (err) {\n        if (err) return callback(err)\n        common.moveApp(opts, tempPath, callback)\n      })\n    })\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-electron-packager/node_modules/electron-packager/mac.js":"'use strict'\n\nconst common = require('./common')\nconst debug = require('debug')('electron-packager')\nconst fs = require('fs-extra')\nconst path = require('path')\nconst plist = require('plist')\nconst series = require('run-series')\nconst sign = require('electron-osx-sign')\n\nclass MacApp {\n  constructor (opts, stagingPath) {\n    this.opts = opts\n    this.stagingPath = stagingPath\n    this.appName = opts.name\n    this.operations = []\n    this.renamedAppPath = path.join(this.stagingPath, `${common.sanitizeAppName(this.appName)}.app`)\n    this.electronAppPath = path.join(this.stagingPath, 'Electron.app')\n    this.contentsPath = path.join(this.electronAppPath, 'Contents')\n    this.frameworksPath = path.join(this.contentsPath, 'Frameworks')\n    this.resourcesPath = path.join(this.contentsPath, 'Resources')\n  }\n\n  get appCategoryType () {\n    return this.opts.appCategoryType\n  }\n\n  get appCopyright () {\n    return this.opts.appCopyright\n  }\n\n  get appVersion () {\n    return this.opts.appVersion\n  }\n\n  get buildVersion () {\n    return this.opts.buildVersion\n  }\n\n  get protocols () {\n    return this.opts.protocols.map((protocol) => {\n      return {\n        CFBundleURLName: protocol.name,\n        CFBundleURLSchemes: [].concat(protocol.schemes)\n      }\n    })\n  }\n\n  updatePlist (base, displayName, identifier, name) {\n    return Object.assign(base, {\n      CFBundleDisplayName: displayName,\n      CFBundleExecutable: common.sanitizeAppName(displayName),\n      CFBundleIdentifier: identifier,\n      CFBundleName: common.sanitizeAppName(name)\n    })\n  }\n\n  updateHelperPlist (base, suffix) {\n    let helperSuffix, identifier, name\n    if (suffix) {\n      helperSuffix = `Helper ${suffix}`\n      identifier = `${this.helperBundleIdentifier}.${suffix}`\n      name = `${this.appName} ${helperSuffix}`\n    } else {\n      helperSuffix = 'Helper'\n      identifier = this.helperBundleIdentifier\n      name = this.appName\n    }\n    return this.updatePlist(base, `${this.appName} ${helperSuffix}`, identifier, name)\n  }\n\n  extendAppPlist (props) {\n    let extendedAppPlist = props\n\n    if (typeof props === 'string') {\n      extendedAppPlist = plist.parse(fs.readFileSync(props).toString())\n    }\n\n    return Object.assign(this.appPlist, extendedAppPlist)\n  }\n\n  loadPlist (filename) {\n    return plist.parse(fs.readFileSync(filename).toString())\n  }\n\n  ehPlistFilename (helper) {\n    return path.join(this.frameworksPath, helper, 'Contents', 'Info.plist')\n  }\n\n  updatePlistFiles () {\n    let appPlistFilename = path.join(this.contentsPath, 'Info.plist')\n    let helperPlistFilename = this.ehPlistFilename('Electron Helper.app')\n    let helperEHPlistFilename = this.ehPlistFilename('Electron Helper EH.app')\n    let helperNPPlistFilename = this.ehPlistFilename('Electron Helper NP.app')\n    this.appPlist = this.loadPlist(appPlistFilename)\n    let helperPlist = this.loadPlist(helperPlistFilename)\n    let helperEHPlist = this.loadPlist(helperEHPlistFilename)\n    let helperNPPlist = this.loadPlist(helperNPPlistFilename)\n\n    let defaultBundleName = `com.electron.${common.sanitizeAppName(this.appName).toLowerCase()}`\n\n    let appBundleIdentifier = filterCFBundleIdentifier(this.opts.appBundleId || defaultBundleName)\n    this.helperBundleIdentifier = filterCFBundleIdentifier(this.opts.helperBundleId || `${appBundleIdentifier}.helper`)\n\n    if (this.opts.extendInfo) {\n      this.appPlist = this.extendAppPlist(this.opts.extendInfo)\n    }\n\n    this.appPlist = this.updatePlist(this.appPlist, this.appName, appBundleIdentifier, this.appName)\n    helperPlist = this.updateHelperPlist(helperPlist)\n    helperEHPlist = this.updateHelperPlist(helperEHPlist, 'EH')\n    helperNPPlist = this.updateHelperPlist(helperNPPlist, 'NP')\n\n    if (this.appVersion) {\n      this.appPlist.CFBundleShortVersionString = this.appPlist.CFBundleVersion = '' + this.appVersion\n    }\n\n    if (this.buildVersion) {\n      this.appPlist.CFBundleVersion = '' + this.buildVersion\n    }\n\n    if (this.opts.protocols && this.opts.protocols.length) {\n      this.appPlist.CFBundleURLTypes = this.protocols\n    }\n\n    if (this.appCategoryType) {\n      this.appPlist.LSApplicationCategoryType = this.appCategoryType\n    }\n\n    if (this.appCopyright) {\n      this.appPlist.NSHumanReadableCopyright = this.appCopyright\n    }\n\n    fs.writeFileSync(appPlistFilename, plist.build(this.appPlist))\n    fs.writeFileSync(helperPlistFilename, plist.build(helperPlist))\n    fs.writeFileSync(helperEHPlistFilename, plist.build(helperEHPlist))\n    fs.writeFileSync(helperNPPlistFilename, plist.build(helperNPPlist))\n  }\n\n  moveHelpers (callback) {\n    series([' Helper', ' Helper EH', ' Helper NP'].map((suffix) => {\n      return (cb) => {\n        let executableBasePath = path.join(this.frameworksPath, `Electron${suffix}.app`, 'Contents', 'MacOS')\n\n        common.rename(executableBasePath, `Electron${suffix}`, `${common.sanitizeAppName(this.appName)}${suffix}`, (err) => {\n          if (err) return cb(err)\n          common.rename(this.frameworksPath, `Electron${suffix}.app`, `${common.sanitizeAppName(this.appName)}${suffix}.app`, cb)\n        })\n      }\n    }), (err) => {\n      callback(err)\n    })\n  }\n\n  enqueueCopyingIcon () {\n    this.operations.push((cb) => {\n      common.normalizeExt(this.opts.icon, '.icns', (err, icon) => {\n        if (err) {\n          // Ignore error if icon doesn't exist, in case it's only available for other OS\n          cb(null)\n        } else {\n          debug(`Copying icon \"${icon}\" to app's Resources as \"${this.appPlist.CFBundleIconFile}\"`)\n          fs.copy(icon, path.join(this.resourcesPath, this.appPlist.CFBundleIconFile), cb)\n        }\n      })\n    })\n  }\n\n  enqueueCopyingExtraFiles (extras) {\n    if (!Array.isArray(extras)) extras = [extras]\n    extras.forEach((filename) => {\n      this.operations.push((cb) => {\n        fs.copy(filename, path.join(this.resourcesPath, path.basename(filename)), cb)\n      })\n    })\n  }\n\n  enqueueRenamingElectronBinary () {\n    this.operations.push((cb) => {\n      common.rename(path.join(this.contentsPath, 'MacOS'),\n                    'Electron',\n                    this.appPlist.CFBundleExecutable,\n                    cb)\n    })\n  }\n\n  enqueueRenamingAppAndHelpers () {\n    this.operations.push((cb) => {\n      this.moveHelpers(cb)\n    }, (cb) => {\n      fs.rename(this.electronAppPath, this.renamedAppPath, cb)\n    })\n  }\n\n  enqueueAppSigningIfSpecified () {\n    let osxSignOpt = this.opts.osxSign\n    let platform = this.opts.platform\n    let version = this.opts.electronVersion\n\n    if ((platform === 'all' || platform === 'mas') &&\n        osxSignOpt === undefined) {\n      common.warning('signing is required for mas builds. Provide the osx-sign option, ' +\n                     'or manually sign the app later.')\n    }\n\n    if (osxSignOpt) {\n      this.operations.push((cb) => {\n        let signOpts = createSignOpts(osxSignOpt, platform, this.renamedAppPath, version, this.opts.quiet)\n        debug(`Running electron-osx-sign with the options ${JSON.stringify(signOpts)}`)\n        sign(signOpts, (err) => {\n          if (err) {\n            // Although not signed successfully, the application is packed.\n            common.warning('Code sign failed; please retry manually.', err)\n          }\n          cb()\n        })\n      })\n    }\n  }\n\n  executeOperations (callback) {\n    series(this.operations, (err) => {\n      if (err) return callback(err)\n      common.moveApp(this.opts, this.stagingPath, callback)\n    })\n  }\n}\n\n// Remove special characters and allow only alphanumeric (A-Z,a-z,0-9), hyphen (-), and period (.)\n// Apple documentation:\n// https://developer.apple.com/library/mac/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html#//apple_ref/doc/uid/20001431-102070\nfunction filterCFBundleIdentifier (identifier) {\n  return identifier.replace(/ /g, '-').replace(/[^a-zA-Z0-9.-]/g, '')\n}\n\nfunction createSignOpts (properties, platform, app, version, quiet) {\n  // use default sign opts if osx-sign is true, otherwise clone osx-sign object\n  let signOpts = properties === true ? {identity: null} : Object.assign({}, properties)\n\n  // osx-sign options are handed off to sign module, but\n  // with a few additions from the main options\n  // user may think they can pass platform, app, or version, but they will be ignored\n  common.subOptionWarning(signOpts, 'osx-sign', 'platform', platform, quiet)\n  common.subOptionWarning(signOpts, 'osx-sign', 'app', app, quiet)\n  common.subOptionWarning(signOpts, 'osx-sign', 'version', version, quiet)\n\n  if (signOpts.binaries) {\n    common.warning('osx-sign.binaries is not an allowed sub-option. Not passing to electron-osx-sign.')\n    delete signOpts.binaries\n  }\n\n  // Take argument osx-sign as signing identity:\n  // if opts.osxSign is true (bool), fallback to identity=null for\n  // autodiscovery. Otherwise, provide signing certificate info.\n  if (signOpts.identity === true) {\n    signOpts.identity = null\n  }\n\n  return signOpts\n}\n\nmodule.exports = {\n  createApp: function createApp (opts, templatePath, callback) {\n    let appRelativePath = path.join('Electron.app', 'Contents', 'Resources', 'app')\n    common.initializeApp(opts, templatePath, appRelativePath, function buildMacApp (err, stagingPath) {\n      if (err) return callback(err)\n\n      let appCreator = new MacApp(opts, stagingPath)\n      appCreator.updatePlistFiles()\n\n      if (opts.icon) {\n        appCreator.enqueueCopyingIcon()\n      }\n\n      if (opts.extraResource) {\n        appCreator.enqueueCopyingExtraFiles(opts.extraResource)\n      }\n\n      appCreator.enqueueRenamingElectronBinary()\n      appCreator.enqueueRenamingAppAndHelpers()\n      appCreator.enqueueAppSigningIfSpecified()\n\n      return appCreator.executeOperations(callback)\n    })\n  },\n  createSignOpts: createSignOpts,\n  filterCFBundleIdentifier: filterCFBundleIdentifier\n}\n","/home/travis/build/npmtest/node-npmtest-electron-packager/node_modules/electron-packager/win32.js":"'use strict'\n\nconst common = require('./common')\nconst debug = require('debug')('electron-packager')\nconst path = require('path')\nconst series = require('run-series')\n\nfunction generateRceditOptionsSansIcon (opts) {\n  const win32metadata = Object.assign({}, opts['version-string'], opts.win32metadata)\n\n  let rcOpts = {'version-string': win32metadata}\n\n  if (opts.appVersion) {\n    rcOpts['product-version'] = rcOpts['file-version'] = opts.appVersion\n  }\n\n  if (opts.buildVersion) {\n    rcOpts['file-version'] = opts.buildVersion\n  }\n\n  if (opts.appCopyright) {\n    rcOpts['version-string'].LegalCopyright = opts.appCopyright\n  }\n\n  return rcOpts\n}\n\nfunction updateWineMissingException (err) {\n  if (err && err.code === 'ENOENT' && err.syscall === 'spawn wine') {\n    err.message = 'Could not find \"wine\" on your system.\\n\\n' +\n      'Wine is required to use the app-copyright, app-version, build-version, icon, and \\n' +\n      'win32metadata parameters for Windows targets.\\n\\n' +\n      'Make sure that the \"wine\" executable is in your PATH.\\n\\n' +\n      'See https://github.com/electron-userland/electron-packager#building-windows-apps-from-non-windows-platforms for details.'\n  }\n\n  return err\n}\n\nmodule.exports = {\n  createApp: function createApp (opts, templatePath, callback) {\n    common.initializeApp(opts, templatePath, path.join('resources', 'app'), function buildWinApp (err, tempPath) {\n      if (err) return callback(err)\n\n      let newExeName = `${common.sanitizeAppName(opts.name)}.exe`\n      var operations = [\n        function (cb) {\n          common.rename(tempPath, 'electron.exe', newExeName, cb)\n        }\n      ]\n\n      const rcOpts = generateRceditOptionsSansIcon(opts)\n\n      if (opts.icon || opts.win32metadata || opts['version-string'] || opts.appCopyright || opts.appVersion || opts.buildVersion) {\n        operations.push(function (cb) {\n          common.normalizeExt(opts.icon, '.ico', function (err, icon) {\n            // Icon might be omitted or only exist in one OS's format, so skip it if normalizeExt reports an error\n            if (!err) {\n              rcOpts.icon = icon\n            }\n\n            debug(`Running rcedit with the options ${JSON.stringify(rcOpts)}`)\n            require('rcedit')(path.join(tempPath, newExeName), rcOpts, function (err) {\n              cb(updateWineMissingException(err))\n            })\n          })\n        })\n      }\n\n      series(operations, function (err) {\n        if (err) return callback(err)\n        common.moveApp(opts, tempPath, callback)\n      })\n    })\n  },\n  generateRceditOptionsSansIcon: generateRceditOptionsSansIcon,\n  updateWineMissingException: updateWineMissingException\n}\n"}